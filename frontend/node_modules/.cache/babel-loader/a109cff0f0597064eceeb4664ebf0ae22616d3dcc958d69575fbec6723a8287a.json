{"ast":null,"code":"/**\n * Extract source information from generation logs\n * @param {string[]} logs - Array of log messages\n * @returns {Object} Sources object with categorized sources\n */\nexport const extractSourcesFromLogs = logs => {\n  const sources = {\n    pdfs: [],\n    news: [],\n    posts: [],\n    web: []\n  };\n\n  // Combine all logs into a single string for pattern matching\n  const currentLog = logs.join('\\n');\n\n  // Extract PDF sources - look for \"Source PDF:\" pattern\n  if (currentLog.includes('Source PDF:')) {\n    const pdfMatches = currentLog.match(/Source PDF: ([^\\n]+)/g);\n    if (pdfMatches) {\n      const pdfSources = pdfMatches.map(match => match.replace('Source PDF: ', '').trim());\n      sources.pdfs = [...new Set(pdfSources)]; // Remove duplicates\n    }\n  }\n\n  // Extract news article sources - look for \"Article X:\" pattern\n  if (currentLog.includes('Article ') && currentLog.includes('Title:')) {\n    const articleBlocks = currentLog.match(/Article \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*Source: ([^\\n]+)[\\s\\S]*?\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    if (articleBlocks) {\n      articleBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const sourceMatch = block.match(/Source: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        if (titleMatch && sourceMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const source = sourceMatch[1].trim();\n          const url = urlMatch[1].trim();\n          if (title && title !== 'N/A') {\n            sources.news.push({\n              title,\n              url,\n              source\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract web search results - look for \"Result X:\" pattern (different from news articles)\n  if (currentLog.includes('MCP Tool: Searching web') || currentLog.includes('Result ') && currentLog.includes('Title:') && currentLog.includes('URL:')) {\n    const webBlocks = currentLog.match(/Result \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    if (webBlocks) {\n      webBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        if (titleMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const url = urlMatch[1].trim();\n          if (title && title !== 'N/A' && !url.toLowerCase().includes('newsapi')) {\n            sources.web.push({\n              title,\n              url\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract viral post sources - look for \"Viral Post Example X:\" pattern\n  if (currentLog.includes('Viral Post Example')) {\n    const viralBlocks = currentLog.match(/Viral Post Example \\d+:[\\s\\S]*?Source: ([^,\\n]+)(?:, Views: ([^,\\n]+))?(?:, Reactions: ([^,\\n]+))?/gm);\n    if (viralBlocks) {\n      viralBlocks.forEach(block => {\n        const sourceMatch = block.match(/Source: ([^,\\n]+)/);\n        const viewsMatch = block.match(/Views: ([^,\\n]+)/);\n        const reactionsMatch = block.match(/Reactions: ([^,\\n]+)/);\n        if (sourceMatch) {\n          const source = sourceMatch[1].trim();\n          const views = viewsMatch ? viewsMatch[1].trim() : 'Unknown';\n          const reactions = reactionsMatch ? reactionsMatch[1].trim() : 'Unknown';\n          if (source && source !== 'N/A' && source !== 'Unknown') {\n            sources.posts.push({\n              source,\n              views,\n              reactions\n            });\n          }\n        }\n      });\n    }\n  }\n  return sources;\n};\n\n/**\n * Check if sources object has any content\n * @param {Object} sources - Sources object\n * @returns {boolean} True if any sources exist\n */\nexport const hasAnySources = sources => {\n  return Object.values(sources).some(sourceArray => sourceArray.length > 0);\n};","map":{"version":3,"names":["extractSourcesFromLogs","logs","sources","pdfs","news","posts","web","currentLog","join","includes","pdfMatches","match","pdfSources","map","replace","trim","Set","articleBlocks","forEach","block","titleMatch","sourceMatch","urlMatch","title","source","url","push","webBlocks","toLowerCase","viralBlocks","viewsMatch","reactionsMatch","views","reactions","hasAnySources","Object","values","some","sourceArray","length"],"sources":["/Users/danielrosario/Desktop/CodeProjects/AudienceAI/frontend/src/utils/sourceExtractor.js"],"sourcesContent":["/**\n * Extract source information from generation logs\n * @param {string[]} logs - Array of log messages\n * @returns {Object} Sources object with categorized sources\n */\nexport const extractSourcesFromLogs = (logs) => {\n  const sources = {\n    pdfs: [],\n    news: [],\n    posts: [],\n    web: []\n  };\n\n  // Combine all logs into a single string for pattern matching\n  const currentLog = logs.join('\\n');\n\n  // Extract PDF sources - look for \"Source PDF:\" pattern\n  if (currentLog.includes('Source PDF:')) {\n    const pdfMatches = currentLog.match(/Source PDF: ([^\\n]+)/g);\n    if (pdfMatches) {\n      const pdfSources = pdfMatches.map(match => match.replace('Source PDF: ', '').trim());\n      sources.pdfs = [...new Set(pdfSources)]; // Remove duplicates\n    }\n  }\n\n  // Extract news article sources - look for \"Article X:\" pattern\n  if (currentLog.includes('Article ') && currentLog.includes('Title:')) {\n    const articleBlocks = currentLog.match(/Article \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*Source: ([^\\n]+)[\\s\\S]*?\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    \n    if (articleBlocks) {\n      articleBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const sourceMatch = block.match(/Source: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        \n        if (titleMatch && sourceMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const source = sourceMatch[1].trim();\n          const url = urlMatch[1].trim();\n          \n          if (title && title !== 'N/A') {\n            sources.news.push({\n              title,\n              url,\n              source\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract web search results - look for \"Result X:\" pattern (different from news articles)\n  if (currentLog.includes('MCP Tool: Searching web') || \n      (currentLog.includes('Result ') && currentLog.includes('Title:') && currentLog.includes('URL:'))) {\n    const webBlocks = currentLog.match(/Result \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    \n    if (webBlocks) {\n      webBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        \n        if (titleMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const url = urlMatch[1].trim();\n          \n          if (title && title !== 'N/A' && !url.toLowerCase().includes('newsapi')) {\n            sources.web.push({\n              title,\n              url\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract viral post sources - look for \"Viral Post Example X:\" pattern\n  if (currentLog.includes('Viral Post Example')) {\n    const viralBlocks = currentLog.match(/Viral Post Example \\d+:[\\s\\S]*?Source: ([^,\\n]+)(?:, Views: ([^,\\n]+))?(?:, Reactions: ([^,\\n]+))?/gm);\n    \n    if (viralBlocks) {\n      viralBlocks.forEach(block => {\n        const sourceMatch = block.match(/Source: ([^,\\n]+)/);\n        const viewsMatch = block.match(/Views: ([^,\\n]+)/);\n        const reactionsMatch = block.match(/Reactions: ([^,\\n]+)/);\n        \n        if (sourceMatch) {\n          const source = sourceMatch[1].trim();\n          const views = viewsMatch ? viewsMatch[1].trim() : 'Unknown';\n          const reactions = reactionsMatch ? reactionsMatch[1].trim() : 'Unknown';\n          \n          if (source && source !== 'N/A' && source !== 'Unknown') {\n            sources.posts.push({\n              source,\n              views,\n              reactions\n            });\n          }\n        }\n      });\n    }\n  }\n\n  return sources;\n};\n\n/**\n * Check if sources object has any content\n * @param {Object} sources - Sources object\n * @returns {boolean} True if any sources exist\n */\nexport const hasAnySources = (sources) => {\n  return Object.values(sources).some(sourceArray => sourceArray.length > 0);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}