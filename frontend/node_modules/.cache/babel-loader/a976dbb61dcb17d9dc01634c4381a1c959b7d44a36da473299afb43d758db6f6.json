{"ast":null,"code":"/**\n * Extract source information from generation logs\n * @param {string[]} logs - Array of log messages\n * @returns {Object} Sources object with categorized sources\n */\nexport const extractSourcesFromLogs = logs => {\n  const sources = {\n    pdfs: [],\n    news: [],\n    posts: [],\n    web: []\n  };\n\n  // Combine all logs into a single string for pattern matching\n  const currentLog = logs.join('\\n');\n\n  // Extract PDF sources - look for \"Source PDF:\" pattern and document URLs\n  if (currentLog.includes('Source PDF:')) {\n    const pdfMatches = currentLog.match(/Source PDF: ([^\\n]+)/g);\n    if (pdfMatches) {\n      const pdfSources = pdfMatches.map(match => match.replace('Source PDF: ', '').trim());\n      sources.pdfs = [...new Set(pdfSources)].map(filename => ({\n        filename,\n        url: null\n      })); // Initialize with no URLs\n    }\n  }\n\n  // Extract document access URLs and match them to PDF sources\n  if (currentLog.includes('Document Access URLs')) {\n    const urlSection = currentLog.match(/Document Access URLs \\(valid for [^)]+\\):\\n([\\s\\S]*?)(?=\\n\\n|\\n---|\\nSource PDFs used:|$)/);\n    if (urlSection && urlSection[1]) {\n      const urlMatches = urlSection[1].match(/• ([^:]+): (https?:\\/\\/[^\\s\\n]+)/g);\n      if (urlMatches) {\n        urlMatches.forEach(match => {\n          const [, filename, url] = match.match(/• ([^:]+): (https?:\\/\\/[^\\s\\n]+)/);\n          if (filename && url) {\n            // Find the corresponding PDF source and add the URL\n            const pdfIndex = sources.pdfs.findIndex(pdf => typeof pdf === 'object' ? pdf.filename === filename.trim() : pdf === filename.trim());\n            if (pdfIndex !== -1) {\n              // Update existing PDF source with URL\n              sources.pdfs[pdfIndex] = {\n                filename: filename.trim(),\n                url: url.trim()\n              };\n            } else {\n              // Add new PDF source with URL if not found\n              sources.pdfs.push({\n                filename: filename.trim(),\n                url: url.trim()\n              });\n            }\n          }\n        });\n      }\n    }\n  }\n\n  // Ensure all PDF sources have the correct structure (filename, url)\n  sources.pdfs = sources.pdfs.map(pdf => {\n    if (typeof pdf === 'string') {\n      return {\n        filename: pdf,\n        url: null\n      };\n    }\n    return pdf;\n  });\n\n  // Extract news article sources - look for \"Article X:\" pattern\n  if (currentLog.includes('Article ') && currentLog.includes('Title:')) {\n    const articleBlocks = currentLog.match(/Article \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*Source: ([^\\n]+)[\\s\\S]*?\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    if (articleBlocks) {\n      articleBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const sourceMatch = block.match(/Source: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        if (titleMatch && sourceMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const source = sourceMatch[1].trim();\n          const url = urlMatch[1].trim();\n          if (title && title !== 'N/A') {\n            sources.news.push({\n              title,\n              url,\n              source\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract web search results - look for \"Result X:\" pattern (different from news articles)\n  if (currentLog.includes('MCP Tool: Searching web') || currentLog.includes('Result ') && currentLog.includes('Title:') && currentLog.includes('URL:')) {\n    const webBlocks = currentLog.match(/Result \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    if (webBlocks) {\n      webBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        if (titleMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const url = urlMatch[1].trim();\n          if (title && title !== 'N/A' && !url.toLowerCase().includes('newsapi')) {\n            sources.web.push({\n              title,\n              url\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract viral post sources - look for \"Viral Post Example X:\" pattern\n  if (currentLog.includes('Viral Post Example')) {\n    const viralBlocks = currentLog.match(/Viral Post Example \\d+:[\\s\\S]*?Source: ([^,\\n]+)(?:, Views: ([^,\\n]+))?(?:, Reactions: ([^,\\n]+))?/gm);\n    if (viralBlocks) {\n      viralBlocks.forEach(block => {\n        const sourceMatch = block.match(/Source: ([^,\\n]+)/);\n        const viewsMatch = block.match(/Views: ([^,\\n]+)/);\n        const reactionsMatch = block.match(/Reactions: ([^,\\n]+)/);\n        if (sourceMatch) {\n          const source = sourceMatch[1].trim();\n          const views = viewsMatch ? viewsMatch[1].trim() : 'Unknown';\n          const reactions = reactionsMatch ? reactionsMatch[1].trim() : 'Unknown';\n          if (source && source !== 'N/A' && source !== 'Unknown') {\n            sources.posts.push({\n              source,\n              views,\n              reactions\n            });\n          }\n        }\n      });\n    }\n  }\n  return sources;\n};\n\n/**\n * Check if sources object has any content\n * @param {Object} sources - Sources object\n * @returns {boolean} True if any sources exist\n */\nexport const hasAnySources = sources => {\n  return Object.values(sources).some(sourceArray => sourceArray.length > 0);\n};","map":{"version":3,"names":["extractSourcesFromLogs","logs","sources","pdfs","news","posts","web","currentLog","join","includes","pdfMatches","match","pdfSources","map","replace","trim","Set","filename","url","urlSection","urlMatches","forEach","pdfIndex","findIndex","pdf","push","articleBlocks","block","titleMatch","sourceMatch","urlMatch","title","source","webBlocks","toLowerCase","viralBlocks","viewsMatch","reactionsMatch","views","reactions","hasAnySources","Object","values","some","sourceArray","length"],"sources":["/Users/danielrosario/Desktop/CodeProjects/AudienceAI/frontend/src/utils/sourceExtractor.js"],"sourcesContent":["/**\n * Extract source information from generation logs\n * @param {string[]} logs - Array of log messages\n * @returns {Object} Sources object with categorized sources\n */\nexport const extractSourcesFromLogs = (logs) => {\n  const sources = {\n    pdfs: [],\n    news: [],\n    posts: [],\n    web: []\n  };\n\n  // Combine all logs into a single string for pattern matching\n  const currentLog = logs.join('\\n');\n\n  // Extract PDF sources - look for \"Source PDF:\" pattern and document URLs\n  if (currentLog.includes('Source PDF:')) {\n    const pdfMatches = currentLog.match(/Source PDF: ([^\\n]+)/g);\n    if (pdfMatches) {\n      const pdfSources = pdfMatches.map(match => match.replace('Source PDF: ', '').trim());\n      sources.pdfs = [...new Set(pdfSources)].map(filename => ({ filename, url: null })); // Initialize with no URLs\n    }\n  }\n\n  // Extract document access URLs and match them to PDF sources\n  if (currentLog.includes('Document Access URLs')) {\n    const urlSection = currentLog.match(/Document Access URLs \\(valid for [^)]+\\):\\n([\\s\\S]*?)(?=\\n\\n|\\n---|\\nSource PDFs used:|$)/);\n    \n    if (urlSection && urlSection[1]) {\n      const urlMatches = urlSection[1].match(/• ([^:]+): (https?:\\/\\/[^\\s\\n]+)/g);\n      \n      if (urlMatches) {\n        urlMatches.forEach(match => {\n          const [, filename, url] = match.match(/• ([^:]+): (https?:\\/\\/[^\\s\\n]+)/);\n          if (filename && url) {\n            // Find the corresponding PDF source and add the URL\n            const pdfIndex = sources.pdfs.findIndex(pdf => \n              typeof pdf === 'object' ? pdf.filename === filename.trim() : pdf === filename.trim()\n            );\n            \n            if (pdfIndex !== -1) {\n              // Update existing PDF source with URL\n              sources.pdfs[pdfIndex] = {\n                filename: filename.trim(),\n                url: url.trim()\n              };\n            } else {\n              // Add new PDF source with URL if not found\n              sources.pdfs.push({\n                filename: filename.trim(),\n                url: url.trim()\n              });\n            }\n          }\n        });\n      }\n    }\n  }\n\n  // Ensure all PDF sources have the correct structure (filename, url)\n  sources.pdfs = sources.pdfs.map(pdf => {\n    if (typeof pdf === 'string') {\n      return { filename: pdf, url: null };\n    }\n    return pdf;\n  });\n\n  // Extract news article sources - look for \"Article X:\" pattern\n  if (currentLog.includes('Article ') && currentLog.includes('Title:')) {\n    const articleBlocks = currentLog.match(/Article \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*Source: ([^\\n]+)[\\s\\S]*?\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    \n    if (articleBlocks) {\n      articleBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const sourceMatch = block.match(/Source: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        \n        if (titleMatch && sourceMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const source = sourceMatch[1].trim();\n          const url = urlMatch[1].trim();\n          \n          if (title && title !== 'N/A') {\n            sources.news.push({\n              title,\n              url,\n              source\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract web search results - look for \"Result X:\" pattern (different from news articles)\n  if (currentLog.includes('MCP Tool: Searching web') || \n      (currentLog.includes('Result ') && currentLog.includes('Title:') && currentLog.includes('URL:'))) {\n    const webBlocks = currentLog.match(/Result \\d+:\\s*\\n\\s*Title: ([^\\n]+)\\s*\\n\\s*URL: (https?:\\/\\/[^\\s\\n]+)/gm);\n    \n    if (webBlocks) {\n      webBlocks.forEach(block => {\n        const titleMatch = block.match(/Title: ([^\\n]+)/);\n        const urlMatch = block.match(/URL: (https?:\\/\\/[^\\s\\n]+)/);\n        \n        if (titleMatch && urlMatch) {\n          const title = titleMatch[1].trim();\n          const url = urlMatch[1].trim();\n          \n          if (title && title !== 'N/A' && !url.toLowerCase().includes('newsapi')) {\n            sources.web.push({\n              title,\n              url\n            });\n          }\n        }\n      });\n    }\n  }\n\n  // Extract viral post sources - look for \"Viral Post Example X:\" pattern\n  if (currentLog.includes('Viral Post Example')) {\n    const viralBlocks = currentLog.match(/Viral Post Example \\d+:[\\s\\S]*?Source: ([^,\\n]+)(?:, Views: ([^,\\n]+))?(?:, Reactions: ([^,\\n]+))?/gm);\n    \n    if (viralBlocks) {\n      viralBlocks.forEach(block => {\n        const sourceMatch = block.match(/Source: ([^,\\n]+)/);\n        const viewsMatch = block.match(/Views: ([^,\\n]+)/);\n        const reactionsMatch = block.match(/Reactions: ([^,\\n]+)/);\n        \n        if (sourceMatch) {\n          const source = sourceMatch[1].trim();\n          const views = viewsMatch ? viewsMatch[1].trim() : 'Unknown';\n          const reactions = reactionsMatch ? reactionsMatch[1].trim() : 'Unknown';\n          \n          if (source && source !== 'N/A' && source !== 'Unknown') {\n            sources.posts.push({\n              source,\n              views,\n              reactions\n            });\n          }\n        }\n      });\n    }\n  }\n\n  return sources;\n};\n\n/**\n * Check if sources object has any content\n * @param {Object} sources - Sources object\n * @returns {boolean} True if any sources exist\n */\nexport const hasAnySources = (sources) => {\n  return Object.values(sources).some(sourceArray => sourceArray.length > 0);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}